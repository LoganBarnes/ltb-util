
.. _program_listing_file_include_ltb_util_async_task_runner.hpp:

Program Listing for File async_task_runner.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_ltb_util_async_task_runner.hpp>` (``include/ltb/util/async_task_runner.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // ///////////////////////////////////////////////////////////////////////////////////////
   // Copyright (c) 2021 Logan Barnes - All Rights Reserved
   // ///////////////////////////////////////////////////////////////////////////////////////
   #pragma once
   
   // project
   #include "blocking_queue.hpp"
   #include "result.hpp"
   
   // standard
   #include <atomic>
   #include <functional>
   #include <memory>
   #include <thread>
   
   namespace ltb::util {
   
   template <typename T, typename E = Error>
   class AsyncTaskRunner {
   public:
       using Task          = std::function<Result<T, E>()>;
       using TaskCallback  = std::function<void(T&&)>;
       using ErrorCallback = std::function<void(E&&)>;
   
       explicit AsyncTaskRunner(NotifyCallback task_ready_callback = nullptr);
   
       ~AsyncTaskRunner();
   
       auto schedule_task(Task task, TaskCallback on_completion = nullptr, ErrorCallback on_error = nullptr) -> void;
   
       auto invoke_callbacks_for_finished_tasks(std::size_t max_updates = 10ul) -> bool;
   
       auto invoke_next_callback_blocking() -> void;
   
       [[nodiscard]] auto processing() const -> bool;
   
   private:
       struct TaskToDo {
           Task          task;
           TaskCallback  on_completion;
           ErrorCallback on_error;
   
           explicit TaskToDo(Task task_to_do, TaskCallback on_completion_callback, ErrorCallback on_error_callback)
               : task(std::move(task_to_do)),
                 on_completion(std::move(on_completion_callback)),
                 on_error(std::move(on_error_callback)) {}
       };
   
       struct FinishedTask {
           Result<T, E>  result;
           TaskCallback  on_completion;
           ErrorCallback on_error;
   
           explicit FinishedTask(Result<T, E>  task_result,
                                 TaskCallback  on_completion_callback,
                                 ErrorCallback on_error_callback)
               : result(std::move(task_result)),
                 on_completion(std::move(on_completion_callback)),
                 on_error(std::move(on_error_callback)) {}
       };
   
       BlockingQueue<std::unique_ptr<TaskToDo>> tasks_to_do_;
       BlockingQueue<FinishedTask>              finished_tasks_;
   
       std::thread      task_thread_;
       std::atomic_bool processing_ = false;
   
       auto task_run_loop() -> void;
   };
   
   template <typename T, typename E>
   AsyncTaskRunner<T, E>::AsyncTaskRunner(NotifyCallback task_ready_callback)
       : finished_tasks_(task_ready_callback), task_thread_([this] { task_run_loop(); }) {}
   
   template <typename T, typename E>
   AsyncTaskRunner<T, E>::~AsyncTaskRunner() {
       tasks_to_do_.clear();
       tasks_to_do_.emplace_back(nullptr); // This forces the task run loop to exit.
       task_thread_.join();
   }
   
   template <typename T, typename E>
   auto AsyncTaskRunner<T, E>::schedule_task(Task task, TaskCallback on_completion, ErrorCallback on_error) -> void {
       if (task == nullptr) {
           throw std::invalid_argument("Task functors cannot be null");
       }
       auto task_to_do = std::make_unique<TaskToDo>(std::move(task), std::move(on_completion), std::move(on_error));
       tasks_to_do_.emplace_back(std::move(task_to_do));
   }
   
   template <typename T, typename E>
   auto AsyncTaskRunner<T, E>::invoke_callbacks_for_finished_tasks(std::size_t max_updates) -> bool {
       for (auto i = 0ul; i < max_updates && !finished_tasks_.empty(); ++i) {
           invoke_next_callback_blocking();
       }
       return !finished_tasks_.empty();
   }
   
   template <typename T, typename E>
   auto AsyncTaskRunner<T, E>::invoke_next_callback_blocking() -> void {
       FinishedTask finished_task = finished_tasks_.pop_front();
       finished_task
           .result
           // call `on_completion` if successful
           .map([&finished_task](T value) {
               if (finished_task.on_completion) {
                   finished_task.on_completion(std::move(value));
               }
           })
           // call `on_error` if there was an error
           .map_error([&finished_task](E error) {
               if (finished_task.on_error) {
                   finished_task.on_error(std::move(error));
               }
           });
   }
   
   template <typename T, typename E>
   auto AsyncTaskRunner<T, E>::processing() const -> bool {
       return processing_;
   }
   
   template <typename T, typename E>
   auto AsyncTaskRunner<T, E>::task_run_loop() -> void {
       while (std::unique_ptr<TaskToDo> task_to_do = tasks_to_do_.pop_front()) {
           processing_ = true;
           finished_tasks_.emplace_back(task_to_do->task(),
                                        std::move(task_to_do->on_completion),
                                        std::move(task_to_do->on_error));
           processing_ = false;
       }
   }
   
   } // namespace ltb::util
